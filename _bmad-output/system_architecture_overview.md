# Conversational Sales Engine: System Architecture Overview

This document provides a detailed technical overview of the **Conversational Sales Engine**, a multi-tenant, state-machine-driven chatbot system integrated with WhatsApp and human agent escalation capabilities.

## 1. Multi-Tenancy Architecture
The system is built on a robust multi-tenant foundation using **Supabase (PostgreSQL)**.

*   **Public Routing**: The `public.client_configs` table acts as the central registry. It maps incoming `channel_id` (e.g., WhatsApp Phone Number ID) and `channel_type` to a specific `client_id` and PostgreSQL `schema_name`.
*   **Schema Isolation**: Each tenant has its own dedicated PostgreSQL schema (e.g., `client_tag_markets`). This schema contains all tenant-specific data, including:
    *   `sessions`: Tracks conversation state and metadata.
    *   `messages`: Complete history of inbound and outbound interactions.
    *   `contacts`: Lead information and CRM data.
    *   `state_machines`: Definitions of the conversational flows.
    *   `pending_messages`: Buffer for the debouncing logic.

## 2. Conversational Engine & State Machine
The core intelligence resides in the `packages/sales-engine`, which implements a dynamic **State Machine**.

*   **States as Data**: State machine configurations are stored as JSONB in the database. This allows tenants to define arbitrary flows (e.g., Lead Qualification -> Pitching -> Closing) without modifying code.
*   **LLM Integration**: The `StateMachine` class guides the LLM (Gemini/Anthropic) by injecting the current state's objective, description, and completion signals into the system prompt.
*   **Transitions**: The LLM recommends state transitions based on "Completion Signals". The engine validates these transitions against the state machine's "Allowed Transitions" before updating the session.

## 3. Message Flow & Debouncing
The system handles high message volume and user "bursts" using a sophisticated debouncing layer.

*   **Webhook Ingress**: The `supabase/functions/webhook-whatsapp` Edge Function receives messages from Meta. It identifies the client via `client-router.ts`.
*   **Buffering**: If debouncing is enabled (configured in `client_configs`), incoming messages are initially saved to the `pending_messages` table.
*   **Worker Processing**: The `supabase/functions/process-pending` function (invoked via pg_cron/self-invocation) periodically scans for "mature" sessions (those past the debounce delay). It merges messages from the same user into a single batch for the LLM, reducing API costs and improving response coherence.

## 4. Human Agent Escalation
When the AI detects that a conversation requires human intervention (e.g., complex queries or direct request for an agent), it triggers an **Escalation**.

*   **Escalation Logic**: The LLM output includes an `escalation` flag and reason. The engine creates a record in the `escalations` table and notifies human agents via WhatsApp templates.
*   **Human Agent App**: A PWA (`apps/human-agent-app`) allows agents to view open escalations and chat directly with customers.
*   **API Relay**: Agent messages are sent via the `supabase/functions/send-human-message` Edge Function, which saves the message to history and relays it back to the customer via the WhatsApp Cloud API.

## 5. Media & RAG
*   **Media Handling**: The system supports images, audio (transcribed via AssemblyAI), and videos. Media is stored in tenant-specific Supabase Storage buckets.
*   **RAG (Retrieval-Augmented Generation)**: The engine integrates with vector stores (Knowledge Bases) to provide contextually accurate answers based on the tenant's own documentation.

---
*Generated by BMad Master for Santiago*
